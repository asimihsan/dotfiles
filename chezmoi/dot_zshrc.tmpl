# add devbox bits to zsh
fpath+=($DEVBOX_GLOBAL_PREFIX/share/zsh/site-functions $DEVBOX_GLOBAL_PREFIX/share/zsh/$ZSH_VERSION/functions $DEVBOX_GLOBAL_PREFIX/share/zsh/vendor-completions)
autoload -U compinit && compinit
eval "$(devbox global shellenv)"

export PATH="$HOME/.bin:$HOME/bin:$PATH"
export PATH="/usr/local/bin:$HOME/bin:$PATH"
eval "$(/opt/homebrew/bin/brew shellenv)"

export PYENV_ROOT="$HOME/.pyenv"
[[ -d $PYENV_ROOT/bin ]] && export PATH="$PYENV_ROOT/bin:$PATH"
eval "$(pyenv init -)"
eval "$(pyenv virtualenv-init -)"

export NVM_DIR="$([ -z "${XDG_CONFIG_HOME-}" ] && printf %s "${HOME}/.nvm" || printf %s "${XDG_CONFIG_HOME}/nvm")"
[ -s "$NVM_DIR/nvm.sh" ] && \. "$NVM_DIR/nvm.sh" # This loads nvm

export PATH="$PATH":$HOME/flutter/bin

source <(fzf --zsh)

export ANDROID_NDK=/opt/homebrew/share/android-ndk
export ANDROID_NDK_HOME=/opt/homebrew/share/android-ndk
export NDK_HOME="$ANDROID_NDK_HOME"
export ANDROID_HOME=/opt/homebrew/share/android-commandlinetools/cmdline-tools/latest/bin

# export PATH="/opt/homebrew/opt/llvm/bin:$PATH"
# export LDFLAGS="-L/opt/homebrew/opt/llvm/lib"
# export CPPFLAGS="-I/opt/homebrew/opt/llvm/include"

export JAVA_HOME=$($HOME/bin/set-java-home.sh)
# export GRAALVM_HOME="/Library/Java/JavaVirtualMachines/graalvm-ce-java17-22.3.0/Contents/Home"
# export PATH="${PATH}":"${GRAALVM_HOME}"/bin
# export PATH=$HOME/.emacs.d/bin:"$PATH"

# brew install coreutils

# brew install vivid
export LS_COLORS="$(vivid generate molokai)"

export PATH="$HOME"/go/bin:"$PATH"

autoload -U +X bashcompinit && bashcompinit

# Hishtory Config:
# export PATH="$PATH:/Users/asimi/.hishtory"
# source /Users/asimi/.hishtory/config.zsh

# Better history
# bindkey -s '^e' "hishtory export | tac | awk '!a[\$0]++' | tac | fzf --scheme=history --tac --no-sort --preview 'echo {}' --preview-window down:5:wrap --bind '?:toggle-preview'^M"

test -e "${HOME}/.iterm2_shell_integration.zsh" && source "${HOME}/.iterm2_shell_integration.zsh"

export DOTNET_CLI_TELEMETRY_OPTOUT=1

[[ -s "/Users/asimi/.gvm/scripts/gvm" ]] && source "/Users/asimi/.gvm/scripts/gvm"

export PATH="${PATH}":/Users/asimi/Library/Application\ Support/JetBrains/Toolbox/scripts/
export PATH=$PATH:$(go env GOPATH)/bin

export PATH="$PATH":"$HOME/.pub-cache/bin"
export PATH=$HOME/flutter/bin:$PATH
export PATH=$PATH:/Users/asimi/.local/bin:/Users/asimi/bin

# -----------------------------------------------------------------------------
#   Homebrew paths.
# -----------------------------------------------------------------------------
# Get the Homebrew base installation directory once
brew_prefix=$(brew --prefix)

# Update PATH for sqlite, tidy-html5, poetry, and protobuf
export PATH="${brew_prefix}/opt/sqlite/bin:$PATH"
export PATH="$PATH:${brew_prefix}/opt/tidy-html5/bin"
export PATH="${brew_prefix}/opt/protobuf/bin:$PATH"

# Set PLANTUML_JAR
export PLANTUML_JAR="${brew_prefix}/opt/plantuml/libexec/plantuml.jar"

# Initialize rbenv
eval "$(${brew_prefix}/opt/rbenv/bin/rbenv init - zsh)"

# alias node=${brew_prefix}/opt/node@20/bin/node
# -----------------------------------------------------------------------------

# -----------------------------------------------------------------------------
#  Secrets from 1Password.
# -----------------------------------------------------------------------------
# Define a function to load a secret from 1Password and export it as an environment variable
load_secret() {
    local secret_path=$1
    local var_name=$2
    export "$var_name"="$(op read --account my.1password.com "op://$secret_path")"
}

# Define a function to load all secrets
load_all_secrets() {
    load_secret "Private/D2 API token/credential" "TSTRUCT_TOKEN"
    load_secret "Private/LocalStack Auth Token/password" "LOCALSTACK_AUTH_TOKEN"
    load_secret "Private/OpenAPI API key work/password" "OPENAI_API_KEY"
    load_secret "Private/Anthropic API key/credential" "ANTHROPIC_API_KEY"
    load_secret "Private/Bing search API key/password" "BING_SEARCH_API_KEY"
    load_secret "Private/Perplexity API key/credential" "PERPLEXITY_API_KEY"
    load_secret "Private/Claude MCP server GitHub Personal Access Token/token" "GITHUB_PERSONAL_ACCESS_TOKEN"


    load_secret "Private/SumoLogic Level/Access ID" "SUMOLOGIC_ACCESS_ID"
    load_secret "Private/SumoLogic Level/Access Key" "SUMOLOGIC_ACCESS_KEY"
    load_secret "pvsttlycpwhbo6vjsedtjbgyc4/mdu_pypi_readonly/username" "POETRY_HTTP_BASIC_DEFAULT_USERNAME"
    load_secret "pvsttlycpwhbo6vjsedtjbgyc4/mdu_pypi_readonly/password" "POETRY_HTTP_BASIC_DEFAULT_PASSWORD"
    load_secret "Private/Level Jira API token/password" "JIRA_API_TOKEN"
    load_secret "Private/Level Jira API token/server" "JIRA_API_SERVER"
    load_secret "Private/Level Jira API token/email" "JIRA_API_EMAIL"
    load_secret "Private/Notion API key for Level workspace/credential" "NOTION_KEY"
    load_secret "Private/Linear API key/password" "LINEAR_API_KEY"
    load_secret "Private/Iterable Level/password" "ITERABLE_API_KEY"




    echo "All secrets have been loaded."
}

# You can now call `load_all_secrets` manually whenever you need to populate the environment variables
# -----------------------------------------------------------------------------

export PATH="$HOME/flutter:$PATH"

alias ll='eza -lh --git'
alias ls="gls --color"
alias du="dust"
alias pmc='coyote test'
alias zstd=$(brew --prefix zstd)/bin/zstd
eval "$(gh copilot alias -- zsh)"
alias vim=nvim
alias lg='GIT_CONFIG_GLOBAL=~/.gitconfig-lazygit lazygit'

eval "$(starship init zsh)"

export _ZO_RESOLVE_SYMLINKS=1  # resolve symlinks
eval "$(zoxide init zsh)"
# alias cd='z'

eval "$(direnv hook zsh)"

# -----------------------------------------------------------------------------
#  atuin configuration.
# -----------------------------------------------------------------------------
if [[ $options[zle] = on ]]; then
  eval "$(atuin init zsh)"
fi
# -----------------------------------------------------------------------------

[ -s "$NVM_DIR/bash_completion" ] && \. "$NVM_DIR/bash_completion"  # This loads nvm bash_completion

. "$HOME/.cargo/env"

source <(git-town completions zsh)

export PATH="$PATH:/Users/asimi/.dotnet/tools"

source <(erd --completions zsh)

export PATH="/opt/homebrew/opt/protobuf@3/bin:$PATH"

export LDFLAGS="-L/opt/homebrew/opt/libiconv/lib"
export CPPFLAGS="-I/opt/homebrew/opt/libiconv/include"

alias ar=/usr/bin/ar


export PATH="/opt/homebrew/opt/node@18/bin:$PATH"


eval "$(mise activate zsh)"

# ---------------------------
# logging
# ---------------------------
LOGDIR="$HOME/logs"
LOGGER_SCRIPT="$HOME/bin/clean_logger.sh"
mkdir -p "$LOGDIR"

# Function to start recording session
function record_session() {
    TIMESTAMP=$(date +%Y%m%d_%H%M%S)
    mkdir -p "$LOGDIR"

    TTY_FILE="$LOGDIR/terminal_${TIMESTAMP}.tty"
    TXT_FILE="$LOGDIR/terminal_${TIMESTAMP}.txt"
    CLEAN_FILE="$LOGDIR/terminal_${TIMESTAMP}_clean.txt"

    echo "Starting recording session..."
    echo "TTY file: $TTY_FILE"
    echo "Text file: $TXT_FILE"
    echo "Clean file: $CLEAN_FILE"

    # Create empty file first
    touch "$TXT_FILE"

    # Start the background cleaner process with nohup
    nohup bash -c "stdbuf -oL tail -f -n +1 \"$TXT_FILE\" | \"$LOGGER_SCRIPT\" > \"$CLEAN_FILE\"" >/dev/null 2>&1 &
    CLEANER_PID=$!

    # Set up cleanup trap for just the cleaner
    trap 'kill $CLEANER_PID 2>/dev/null' EXIT

    # Run script with shell command to execute ttyrec
    script -q "$TXT_FILE" /bin/sh -c "exec ttyrec \"$TTY_FILE\""
}

# Function to view last recording (cleaned)
function lastlog() {
    local LATEST=""

    echo "Searching for log files in $LOGDIR..."

    # List all matching files first
    echo "Found files:"
    cd "$LOGDIR" && fd "terminal.*\.txt$" --type f

    # Try clean file first
    LATEST=$(cd "$LOGDIR" && fd "terminal.*clean\.txt$" --type f --exec-batch ls -t | head -n 1)

    if [[ -z "$LATEST" ]]; then
        echo "No clean files found, trying raw text files..."
        # Try raw text file, excluding clean files
        LATEST=$(cd "$LOGDIR" && fd "terminal.*\.txt$" --type f --exclude "*clean.txt*" --exec-batch ls -t | head -n 1)
    fi

    if [[ -n "$LATEST" && -f "$LOGDIR/$LATEST" && -s "$LOGDIR/$LATEST" ]]; then
        echo "Opening log file: $LATEST"
        less -R "$LOGDIR/$LATEST"
    else
        echo "No valid log files found in $LOGDIR"
        echo "All terminal-related files:"
        cd "$LOGDIR" && fd "terminal" --type f
    fi
}

# Function to open terminal on macOS
function open_new_terminal() {
    local cmd="$1"
    osascript -e "tell application \"Terminal\" to do script \"$cmd\""
}

# Function to play TTY recording
function playtty() {
    local FILE="$1"
    if [[ -z "$FILE" ]]; then
        # Find most recent tty file
        FILE=$(cd "$LOGDIR" && fd "terminal.*\.tty$" --type f --exec-batch ls -t | head -n 1)
        if [[ -n "$FILE" ]]; then
            FILE="$LOGDIR/$FILE"
        fi
    fi

    if [[ -n "$FILE" && -f "$FILE" && -s "$FILE" ]]; then
        echo "Playing TTY file: $FILE"

        if [[ "$TERM" == "xterm-kitty" ]]; then
            # Try kitty first
            if kitty @ ls-windows > /dev/null 2>&1; then
                kitty @ new-window --new-tab ttyplay -n "$FILE"
            else
                echo "Kitty remote control disabled, falling back to new Terminal window..."
                open_new_terminal "ttyplay -n '$FILE'"
            fi
        else
            # For non-Kitty terminals, open in new Terminal window
            open_new_terminal "ttyplay -n '$FILE'"
        fi
    else
        echo "Error: Cannot find valid TTY file"
        echo "Specified file: $FILE"
        echo "Available TTY files:"
        cd "$LOGDIR" && fd "terminal.*\.tty$" --type f
    fi
}

# Function to rotate logs
rotate_logs() {
    fd . "$LOGDIR" --changed-before 7d --type f --threads 1 --exclude "*.zst" --exec zstd -19 --rm {}
}

# Auto-start logging for new sessions
if [[ -z "$LOGGING_STARTED" ]]; then
    export LOGGING_STARTED=1
    record_session
    rotate_logs
fi
# ---------------------------
