#!/usr/bin/env bash

# mac_setup.sh — Idempotent macOS bootstrap / update script
#
# Usage:
#   ./mac_setup.sh [-p profile] [-n new_hostname] [-h]
#
# Options:
#   -p profile        Override auto-detected profile (personal, work, default)
#   -n new_hostname   Set macOS ComputerName/HostName/LocalHostName first
#   -h                Show this help and exit
#
# Examples:
#   ./mac_setup.sh -n hlru5i             # First-time on new personal laptop
#   ./mac_setup.sh                       # Regular update (auto profile)
#   ./mac_setup.sh -p work               # Force work profile
#   sudo ./mac_setup.sh --hostname-only hlru5i
#
# The script is safe to run multiple times; each step is idempotent.

# Special mode:
#   --hostname-only NEWNAME   Only set hostnames and exit. Must be run with sudo.

set -euo pipefail

if [[ ${EUID:-$(id -u)} -eq 0 && ${1:-} != "--hostname-only" ]]; then
  echo "Error: Do not run this script as root. Re-run without sudo." >&2
  echo "Use --hostname-only with sudo if you only need to set hostnames." >&2
  exit 1
fi

SCRIPT_DIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
pushd "$SCRIPT_DIR" >/dev/null

cleanup() {
  # Always restore the original directory and stop the sudo refresh loop (if any).
  popd >/dev/null 2>&1 || true
  if [[ -n "${SUDO_REFRESH_PID:-}" ]]; then
    kill "$SUDO_REFRESH_PID" >/dev/null 2>&1 || true
  fi
}

trap cleanup EXIT

# shellcheck disable=SC2059
fancy_echo() {
  local fmt="$1"; shift
  printf "$fmt\n" "$@"
}

keep_sudo_alive() {
  # Ask once up-front
  sudo -v

  # Refresh every minute until the script ends
  while true; do
    sudo -n true 2>/dev/null
    sleep 60
  done &
  SUDO_REFRESH_PID=$!
}

command_exists() {
  command -v "$1" >/dev/null 2>&1
}

ensure_limit_maxfiles_launchdaemon() {
  # Persist launchd maxfiles across reboot by installing a LaunchDaemon that runs at boot.
  # This is separate from sysctl kernel limits.
  local soft="$1"
  local hard="$2"
  local plist_path="/Library/LaunchDaemons/limit.maxfiles.plist"
  local tmp

  tmp=$(mktemp)
  cat >"$tmp" <<EOF_PLIST
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict>
    <key>Label</key>
    <string>limit.maxfiles</string>
    <key>ProgramArguments</key>
    <array>
      <string>/bin/launchctl</string>
      <string>limit</string>
      <string>maxfiles</string>
      <string>${soft}</string>
      <string>${hard}</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
    <key>ServiceIPC</key>
    <false/>
  </dict>
</plist>
EOF_PLIST

  if ! sudo test -f "$plist_path" || ! sudo cmp -s "$tmp" "$plist_path"; then
    sudo install -m 0644 -o root -g wheel "$tmp" "$plist_path"
    fancy_echo "Updated %s" "$plist_path"
  else
    fancy_echo "%s already up to date." "$plist_path"
  fi

  rm -f "$tmp"

  # Reload job (modern launchctl). If this fails (older macOS), try the legacy load command.
  if sudo launchctl print system/limit.maxfiles >/dev/null 2>&1; then
    sudo launchctl bootout system "$plist_path" >/dev/null 2>&1 || true
  fi

  sudo launchctl bootstrap system "$plist_path" >/dev/null 2>&1 \
    || sudo launchctl load -w "$plist_path" >/dev/null 2>&1 \
    || true

  sudo launchctl enable system/limit.maxfiles >/dev/null 2>&1 || true
  sudo launchctl kickstart -k system/limit.maxfiles >/dev/null 2>&1 || true
}

usage() {
  cat <<USAGE >&2
Usage: $0 [-p profile] [-n new_hostname] [--hostname-only NEWNAME]
  -p profile        Override auto-detected profile (e.g. personal, work)
  -n new_hostname   Set macOS ComputerName/HostName/LocalHostName first
  --hostname-only NEWNAME   Only set the hostnames and exit (requires sudo)
USAGE
}

set_hostnames() {
  local newname="$1"
  # Validate hostname characters (Bonjour rules)
  if [[ ! "$newname" =~ ^[A-Za-z0-9-]+$ ]]; then
    echo "Error: hostname must contain only letters, numbers, and hyphens." >&2
    exit 2
  fi

  fancy_echo "Setting hostnames to '$newname'…"
  sudo scutil --set ComputerName "$newname"
  sudo scutil --set HostName "$newname"
  sudo scutil --set LocalHostName "$newname"
  sudo dscacheutil -flushcache
}

run_profile_tasks() {
  local profile="$1"
  case "$profile" in
    work)
      fancy_echo "Running work profile tasks…"
      # Placeholder for work-specific setup steps
      ;;
    personal)
      fancy_echo "Running personal profile tasks…"
      # Placeholder for personal-specific setup steps
      ;;
    *)
      # default / no-op
      ;;
  esac
}

install_homebrew() {
  if ! command_exists brew; then
    fancy_echo "Installing Homebrew..."
    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
    if [ -x /opt/homebrew/bin/brew ]; then
      eval "$(/opt/homebrew/bin/brew shellenv)"
    elif [ -x /usr/local/bin/brew ]; then
      eval "$(/usr/local/bin/brew shellenv)"
    fi
  else
    fancy_echo "Homebrew already installed."
  fi
}

install_mise() {
  if ! command_exists mise; then
    fancy_echo "Installing mise via Homebrew..."
    brew install mise
  else
    fancy_echo "mise already installed."
  fi
  eval "$(mise activate bash)" || true
}

install_1password_cli() {
  if ! command_exists op; then
    fancy_echo "Installing 1Password CLI via mise..."
    mise use -g 1password
  else
    fancy_echo "1Password CLI already installed."
  fi
  eval "$(mise activate bash)" || true
}

install_gh_cli() {
  if ! command_exists gh; then
    fancy_echo "Installing GitHub CLI via mise..."
    mise use -g gh
  else
    fancy_echo "GitHub CLI already installed."
  fi
  eval "$(mise activate bash)" || true
}

install_chezmoi() {
  if ! command_exists chezmoi; then
    fancy_echo "Installing chezmoi via mise..."
    mise use -g chezmoi
  else
    fancy_echo "chezmoi already installed."
  fi
  eval "$(mise activate bash)" || true
}

ensure_restic_sudoers() {
  local file=/etc/sudoers.d/restic-snapshot
  local tmp
  tmp=$(mktemp)
  cat >"$tmp" <<EOF_SUDO
# restic snapshot privileges for $USER
$USER ALL=(root) NOPASSWD: \
    /usr/bin/tmutil *, \
    /sbin/mount_apfs *, \
    /sbin/umount *, \
    /usr/sbin/diskutil unmount *
EOF_SUDO
  if ! sudo test -f "$file" || ! sudo cmp -s "$tmp" "$file"; then
    sudo install -m 0440 -o root -g wheel "$tmp" "$file"
    sudo visudo -cf "$file" || { echo "sudoers syntax error"; exit 1; }
    fancy_echo "Updated $file"
  fi
  rm -f "$tmp"
}

restic_backup_config_path() {
  local default_config_home="$HOME/.config"
  local xdg_config_home="${XDG_CONFIG_HOME:-$default_config_home}"
  if [[ -n "${RESTIC_BACKUP_CONFIG:-}" ]]; then
    printf "%s\n" "$RESTIC_BACKUP_CONFIG"
  else
    printf "%s/restic-backup/config.toml\n" "$xdg_config_home"
  fi
}

restic_secret_specs_for_host() {
  local host="$1"
  case "$host" in
    yov3bc)
      cat <<'EOF'
restic-repo-main|op://Private/restic-backup-yov3bc-202407 backup password/password
EOF
      ;;
    okzf68)
      cat <<'EOF'
restic-repo-main|op://Private/restic-backup-okzf68-202507 backup password/password
EOF
      ;;
    hlru5i)
      cat <<'EOF'
restic-repo-main|op://Private/restic-backup-hlru5i-202407 backup password/password
EOF
      ;;
    im9ibk)
      cat <<'EOF'
restic-repo-main|op://Private/restic-backup-im9ibk-202507 backup password/password
EOF
      ;;
  esac
}

print_restic_secret_requirements() {
  cat <<'EOF'
Required 1Password secret mappings for restic keychain provisioning:
  service: restic-repo-main
    yov3bc -> op://Private/restic-backup-yov3bc-202407 backup password/password
    okzf68 -> op://Private/restic-backup-okzf68-202507 backup password/password
    hlru5i -> op://Private/restic-backup-hlru5i-202407 backup password/password
    im9ibk -> op://Private/restic-backup-im9ibk-202507 backup password/password

Notes:
  - Expected field is the `password` field on each item.
  - Override per-run with RESTIC_SECRET_PATH (+ optional RESTIC_SECRET_SERVICE).
  - Force update existing keychain values with RESTIC_KEYCHAIN_FORCE_UPDATE=1.
EOF
}

restic_services_from_config() {
  local config_path="$1"
  if [[ ! -r "$config_path" ]]; then
    echo "Error: restic config not found: $config_path" >&2
    return 1
  fi

  restic_services_from_config_fallback() {
    local fallback_path="$1"
    local detected=()
    local line=""
    local service=""

    while IFS= read -r line; do
      [[ "$line" == *"password_command"* ]] || continue
      service="$(printf "%s\n" "$line" | sed -nE "s/.*(--service=|-s[[:space:]]+)([^[:space:]\"']+).*/\\2/p")"
      [[ -n "$service" ]] && detected+=("$service")
    done <"$fallback_path"

    if [[ ${#detected[@]} -eq 0 ]]; then
      detected=("restic-repo-main")
    fi

    printf "%s\n" "${detected[@]}" | awk '!seen[$0]++'
  }

  if ! command_exists python3; then
    echo "Warning: python3 unavailable; using fallback parser for $config_path" >&2
    restic_services_from_config_fallback "$config_path"
    return 0
  fi
  if ! python3 - <<'PY' >/dev/null 2>&1
import tomllib  # noqa: F401
PY
  then
    echo "Warning: python3 lacks tomllib; using fallback parser for $config_path" >&2
    restic_services_from_config_fallback "$config_path"
    return 0
  fi

  if ! python3 - "$config_path" <<'PY'
import shlex
import sys
import tomllib
from pathlib import Path

path = Path(sys.argv[1]).expanduser()
with path.open("rb") as handle:
    data = tomllib.load(handle)

services: list[str] = []


def add_service_from_command(command: object) -> None:
    if not isinstance(command, str):
        return
    tokens = shlex.split(command)
    for index, token in enumerate(tokens):
        if token == "-s" and index + 1 < len(tokens):
            candidate = tokens[index + 1].strip()
            if candidate and candidate not in services:
                services.append(candidate)
            return
        if token.startswith("--service="):
            candidate = token.split("=", 1)[1].strip()
            if candidate and candidate not in services:
                services.append(candidate)
            return


repository = data.get("repository")
if isinstance(repository, dict):
    add_service_from_command(repository.get("password_command"))

repositories = data.get("repositories")
if isinstance(repositories, dict):
    for value in repositories.values():
        if isinstance(value, dict):
            add_service_from_command(value.get("password_command"))

if not services:
    services.append("restic-repo-main")

for service in services:
    print(service)
PY
  then
    echo "Warning: failed to parse $config_path with python tomllib; using fallback parser" >&2
    restic_services_from_config_fallback "$config_path"
  fi
}

op_path_for_service() {
  local wanted_service="$1"
  local specs="$2"
  local spec_service=""
  local spec_path=""

  while IFS='|' read -r spec_service spec_path; do
    [[ -z "$spec_service" ]] && continue
    if [[ "$spec_service" == "$wanted_service" ]]; then
      printf "%s\n" "$spec_path"
      return 0
    fi
  done <<<"$specs"
  return 1
}

ensure_restic_mapping_coverage() {
  local host="$1"
  local specs="$2"
  shift 2
  local services=("$@")
  local missing=()
  local service=""

  for service in "${services[@]}"; do
    if ! op_path_for_service "$service" "$specs" >/dev/null; then
      missing+=("$service")
    fi
  done

  if [[ ${#missing[@]} -gt 0 ]]; then
    echo "Error: missing 1Password mappings for restic service(s): ${missing[*]} on host '$host'" >&2
    print_restic_secret_requirements >&2
    exit 1
  fi

  if [[ "$host" == "hlru5i" ]]; then
    local hlru5i_path=""
    hlru5i_path="$(op_path_for_service "restic-repo-main" "$specs" || true)"
    if [[ -z "$hlru5i_path" || "$hlru5i_path" != *"restic-backup-hlru5i-"* ]]; then
      echo "Error: hlru5i mapping for restic-repo-main is missing or unexpected: $hlru5i_path" >&2
      exit 1
    fi
  fi
}

ensure_keychain_item_from_1password() {
  local service="$1"
  local op_password_path="$2"
  local account="$3"
  local keychain="$4"

  if security find-generic-password -a "$account" -s "$service" "$keychain" >/dev/null 2>&1 \
    && [[ "${RESTIC_KEYCHAIN_FORCE_UPDATE:-0}" != "1" ]]; then
    fancy_echo "Restic keychain item already exists (%s)." "$service"
    return
  fi

  if [[ "${RESTIC_KEYCHAIN_FORCE_UPDATE:-0}" == "1" ]]; then
    fancy_echo "Updating restic keychain item (%s)..." "$service"
  else
    fancy_echo "Adding restic keychain item (%s)..." "$service"
  fi

  if ! command_exists op; then
    echo "Error: 1Password CLI (op) not found; cannot fetch restic secret for '$service'." >&2
    exit 1
  fi

  if [[ -z "$op_password_path" ]]; then
    echo "Error: 1Password path for restic service '$service' is empty." >&2
    print_restic_secret_requirements >&2
    exit 1
  fi

  local restic_pass=""
  if ! restic_pass=$(op read "$op_password_path"); then
    echo "Error: failed to read restic secret for '$service' from '$op_password_path'." >&2
    exit 1
  fi
  if [[ -z "$restic_pass" ]]; then
    echo "Error: 1Password secret for '$service' from '$op_password_path' is empty." >&2
    exit 1
  fi

  security add-generic-password -a "$account" -s "$service" -w "$restic_pass" -U \
    -T /usr/bin/security \
    "$keychain" >/dev/null
}

verify_restic_keychain_passwords() {
  local account="$1"
  local keychain="$2"
  shift 2
  local services=("$@")
  local service=""
  local missing=()

  for service in "${services[@]}"; do
    if ! security find-generic-password -a "$account" -s "$service" "$keychain" >/dev/null 2>&1; then
      missing+=("$service")
    fi
  done

  if [[ ${#missing[@]} -gt 0 ]]; then
    echo "Error: missing restic keychain item(s) after provisioning: ${missing[*]}" >&2
    exit 1
  fi

  fancy_echo "Verified restic keychain item(s): %s" "${services[*]}"
}

ensure_restic_keychain_passwords() {
  local account="$USER"
  local keychain="${RESTIC_KEYCHAIN_PATH:-$HOME/Library/Keychains/login.keychain-db}"
  local current_host
  current_host="$(scutil --get ComputerName 2>/dev/null || hostname)"
  current_host="${current_host%%.*}"

  local config_path
  config_path="$(restic_backup_config_path)"

  local configured_services=()
  while IFS= read -r service; do
    [[ -n "$service" ]] && configured_services+=("$service")
  done < <(restic_services_from_config "$config_path")

  if [[ ${#configured_services[@]} -eq 0 ]]; then
    echo "Error: no restic services discovered from config: $config_path" >&2
    exit 1
  fi

  local secret_specs=""
  if [[ -n "${RESTIC_SECRET_PATH:-}" ]]; then
    local override_service="${RESTIC_SECRET_SERVICE:-}"
    if [[ -z "$override_service" ]]; then
      if [[ ${#configured_services[@]} -eq 1 ]]; then
        override_service="${configured_services[0]}"
      else
        override_service="restic-repo-main"
      fi
    fi
    secret_specs="${override_service}|${RESTIC_SECRET_PATH}"
  else
    secret_specs="$(restic_secret_specs_for_host "$current_host")"
  fi

  if [[ -z "$secret_specs" ]]; then
    echo "Error: no restic 1Password mapping configured for host '$current_host'." >&2
    print_restic_secret_requirements >&2
    exit 1
  fi

  ensure_restic_mapping_coverage "$current_host" "$secret_specs" "${configured_services[@]}"

  local service=""
  local op_password_path=""
  for service in "${configured_services[@]}"; do
    op_password_path="$(op_path_for_service "$service" "$secret_specs" || true)"
    if [[ -z "$op_password_path" ]]; then
      echo "Error: missing 1Password mapping for restic service '$service' on '$current_host'." >&2
      exit 1
    fi
    ensure_keychain_item_from_1password "$service" "$op_password_path" "$account" "$keychain"
  done

  verify_restic_keychain_passwords "$account" "$keychain" "${configured_services[@]}"
}

update_homebrew() {
  brew update --auto-update

  # ruby dependencies
  brew install openssl@3 readline libyaml gmp autoconf

  brew upgrade
  brew bundle install
  brew cleanup --prune=all
}

update_mise() {
  mise cache clear
  mise install
  mise upgrade --yes
  mise prune --yes
}

install_awscli() {
  mise install awscli "ref:$(mise latest awscli 2)"
  mise use -g "awscli@$(mise latest awscli 2)"
}

install_pragmasevka_font() {
  local font_dir="$HOME/Library/Fonts"

  # If the regular style is already present, assume the font is installed.
  if find "$font_dir" -maxdepth 1 -iname "pragmasevka-nf-regular.ttf" | grep -q .; then
    fancy_echo "Pragmasevka font already installed – skipping download."
    return
  fi

  local url="https://github.com/shytikov/pragmasevka/releases/download/v1.7.0/Pragmasevka_NF.zip"
  local expected_sha="eeab758eff562d1caed761244488e56545be25e81a6b40cd84b31b032a37615c"
  local tmp_dir
  tmp_dir=$(mktemp -d)
  local zip_file="$tmp_dir/Pragmasevka_NF.zip"

  fancy_echo "Downloading Pragmasevka font..."
  curl -LfsS -o "$zip_file" "$url"

  fancy_echo "Verifying SHA256 checksum..."
  local actual_sha
  actual_sha=$(shasum -a 256 "$zip_file" | awk '{print $1}')
  if [ "$actual_sha" != "$expected_sha" ]; then
    echo "SHA256 checksum mismatch for Pragmasevka font" >&2
    echo "Expected: $expected_sha" >&2
    echo "Actual:   $actual_sha" >&2
    exit 1
  fi

  fancy_echo "Checksum verified. Installing font..."

  unzip -q "$zip_file" -d "$tmp_dir"

  mkdir -p "$font_dir"
  find "$tmp_dir" -type f \( -name "*.ttf" -o -name "*.otf" \) -exec cp -f {} "$font_dir/" \;

  fancy_echo "Pragmasevka font installed."
}

update_system() {
  sudo softwareupdate --download --all --agree-to-license || true
}

init_chezmoi() {
  install_chezmoi
  fancy_echo "Initializing chezmoi from $SCRIPT_DIR"
  chezmoi init --source "$SCRIPT_DIR" --apply
}

mac_system_setup() {
  fancy_echo "Setting up macOS system..."

  sudo sysctl -w kern.maxfiles=524288
  sudo sysctl -w kern.maxfilesperproc=262144

  # set launchd per-process soft/hard (use numbers, not "unlimited")
  sudo launchctl limit maxfiles 262144 524288
  ensure_limit_maxfiles_launchdaemon 262144 524288

  # 3 is default hibernate mode; copy RAM to hibernation file but keeps RAM powered on.
  # 25 is the most aggressive mode; copy RAM to hibernation file and power off RAM.
  sudo pmset -a hibernatemode 3

  # After 1800 seconds (30 minutes), the system will go into standby mode, which is
  # actually hibernation! (This does not work at least on Mac M1)
  # sudo pmset -a standbydelay 1800

  # Disable Power Nap, which keeps networking alive.
  sudo pmset -a powernap 0

  # Show hidden files in Finder
  defaults write com.apple.Finder AppleShowAllFiles -bool true

  # Show all file extensions in Finder
  defaults write NSGlobalDomain AppleShowAllExtensions -bool true

  # Show the path bath and status bar in Finder
  defaults write com.apple.finder ShowPathbar -bool true
  defaults write com.apple.finder ShowStatusBar -bool true

  # Use list view and search the current folder by default
  defaults write com.apple.Finder FXPreferredViewStyle -string "Nlsv"
  defaults write com.apple.Finder FXDefaultSearchScope -string "SCcf"

  # Unhide the Library folder
  chflags nohidden ~/Library

  # Show the full POSIX path in Finder window titles
  defaults write com.apple.finder _FXShowPosixPathInTitle -bool true

  # Show the ~/Downloads folder in the sidebar
  defaults write com.apple.finder ShowRecentTags -bool false
  defaults write com.apple.finder ShowSidebar -bool true

  # Change screenshot save location
  mkdir -p ~/Pictures/Screenshots
  defaults write com.apple.screencapture location ~/Pictures/Screenshots
  killall SystemUIServer || true

  # Always show scroll bars
  defaults write NSGlobalDomain AppleShowScrollBars -string "Always"

  # Enable tap‑to‑click and two‑finger right‑click
  defaults write com.apple.driver.AppleBluetoothMultitouch.trackpad Clicking -bool true
  defaults write com.apple.AppleMultitouchTrackpad TrackpadRightClick -bool true

  # Increase keyboard repeat speed
  defaults write -g InitialKeyRepeat -int 10
  defaults write -g KeyRepeat -int 1

  # Turn off automatic spelling correction and capitalisation
  defaults write NSGlobalDomain NSAutomaticSpellingCorrectionEnabled -bool false
  defaults write NSGlobalDomain NSAutomaticCapitalizationEnabled -bool false

  # Restart Finder
  killall Finder || true
}

update_cursor_agent() {
  fancy_echo "Updating Cursor agent..."
  if command -v cursor-agent >/dev/null 2>&1; then
    cursor-agent update
  else
    fancy_echo "Cursor agent not installed."
  fi
}

main() {
  # Parse CLI flags early
  local PROFILE=""
  local NEW_HOSTNAME=""
  while getopts "p:n:h" opt; do
    case $opt in
      p) PROFILE=$OPTARG ;;
      n) NEW_HOSTNAME=$OPTARG ;;
      h)
        usage
        return 0
        ;;
      *)
        usage
        return 1
        ;;
    esac
  done
  shift $((OPTIND - 1))

  # Optionally set a new hostname
  if [[ -n "$NEW_HOSTNAME" ]]; then
    set_hostnames "$NEW_HOSTNAME"
  fi

  # Auto-detect profile from current hostname if not provided
  if [[ -z "$PROFILE" ]]; then
    local CURRENT_HOST
    CURRENT_HOST=$(scutil --get ComputerName 2>/dev/null || hostname)
    case "$CURRENT_HOST" in
      hlru5i|im9ibk) PROFILE="personal" ;;
      yov3bc|okzf68) PROFILE="work"     ;;
      *)             PROFILE="default"  ;;
    esac
  fi

  run_profile_tasks "$PROFILE"

  keep_sudo_alive

  install_homebrew
  install_mise
  install_1password_cli
  install_gh_cli
  init_chezmoi
  ensure_restic_keychain_passwords
  ensure_restic_sudoers

  mac_system_setup
  install_pragmasevka_font
  update_homebrew
  install_awscli
  update_mise
  update_system
  update_cursor_agent
  fancy_echo "Mac setup/update complete for profile '$PROFILE'."
}

# Allow unit-style function testing without running main.
if [[ "${MAC_SETUP_SKIP_MAIN:-0}" == "1" ]]; then
  if [[ "${BASH_SOURCE[0]}" != "$0" ]]; then
    return 0
  fi
  exit 0
fi

# If invoked directly with --hostname-only NEWNAME, handle it before main()
if [[ ${1:-} == "--hostname-only" ]]; then
  if [[ $# -ne 2 ]]; then
    echo "Usage: $0 --hostname-only NEWNAME" >&2
    exit 1
  fi
  if [[ ${EUID:-$(id -u)} -ne 0 ]]; then
    echo "Error: --hostname-only must be run with sudo." >&2
    exit 1
  fi
  keep_sudo_alive
  set_hostnames "$2"
  exit 0
fi

main "$@"
