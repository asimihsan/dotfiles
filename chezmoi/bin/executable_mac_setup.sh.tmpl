#!/usr/bin/env bash

# mac_setup.sh — Idempotent macOS bootstrap / update script
#
# Usage:
#   ./mac_setup.sh [-p profile] [-n new_hostname] [-h]
#
# Options:
#   -p profile        Override auto-detected profile (personal, work, default)
#   -n new_hostname   Set macOS ComputerName/HostName/LocalHostName first
#   -h                Show this help and exit
#
# Examples:
#   ./mac_setup.sh -n hlru5i             # First-time on new personal laptop
#   ./mac_setup.sh                       # Regular update (auto profile)
#   ./mac_setup.sh -p work               # Force work profile
#   sudo ./mac_setup.sh --hostname-only hlru5i
#
# The script is safe to run multiple times; each step is idempotent.

# Special mode:
#   --hostname-only NEWNAME   Only set hostnames and exit. Must be run with sudo.

set -euo pipefail

if [[ ${EUID:-$(id -u)} -eq 0 && ${1:-} != "--hostname-only" ]]; then
  echo "Error: Do not run this script as root. Re-run without sudo." >&2
  echo "Use --hostname-only with sudo if you only need to set hostnames." >&2
  exit 1
fi

SCRIPT_DIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
pushd "$SCRIPT_DIR" >/dev/null

cleanup() {
  # Always restore the original directory and stop the sudo refresh loop (if any).
  popd >/dev/null 2>&1 || true
  if [[ -n "${SUDO_REFRESH_PID:-}" ]]; then
    kill "$SUDO_REFRESH_PID" >/dev/null 2>&1 || true
  fi
}

trap cleanup EXIT

# shellcheck disable=SC2059
fancy_echo() {
  local fmt="$1"; shift
  printf "$fmt\n" "$@"
}

keep_sudo_alive() {
  # Ask once up-front
  sudo -v

  # Refresh every minute until the script ends
  while true; do
    sudo -n true 2>/dev/null
    sleep 60
  done &
  SUDO_REFRESH_PID=$!
}

command_exists() {
  command -v "$1" >/dev/null 2>&1
}

ensure_limit_maxfiles_launchdaemon() {
  # Persist launchd maxfiles across reboot by installing a LaunchDaemon that runs at boot.
  # This is separate from sysctl kernel limits.
  local soft="$1"
  local hard="$2"
  local plist_path="/Library/LaunchDaemons/limit.maxfiles.plist"
  local tmp

  tmp=$(mktemp)
  cat >"$tmp" <<EOF_PLIST
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
  <dict>
    <key>Label</key>
    <string>limit.maxfiles</string>
    <key>ProgramArguments</key>
    <array>
      <string>/bin/launchctl</string>
      <string>limit</string>
      <string>maxfiles</string>
      <string>${soft}</string>
      <string>${hard}</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
    <key>ServiceIPC</key>
    <false/>
  </dict>
</plist>
EOF_PLIST

  if ! sudo test -f "$plist_path" || ! sudo cmp -s "$tmp" "$plist_path"; then
    sudo install -m 0644 -o root -g wheel "$tmp" "$plist_path"
    fancy_echo "Updated %s" "$plist_path"
  else
    fancy_echo "%s already up to date." "$plist_path"
  fi

  rm -f "$tmp"

  # Reload job (modern launchctl). If this fails (older macOS), try the legacy load command.
  if sudo launchctl print system/limit.maxfiles >/dev/null 2>&1; then
    sudo launchctl bootout system "$plist_path" >/dev/null 2>&1 || true
  fi

  sudo launchctl bootstrap system "$plist_path" >/dev/null 2>&1 \
    || sudo launchctl load -w "$plist_path" >/dev/null 2>&1 \
    || true

  sudo launchctl enable system/limit.maxfiles >/dev/null 2>&1 || true
  sudo launchctl kickstart -k system/limit.maxfiles >/dev/null 2>&1 || true
}

usage() {
  cat <<USAGE >&2
Usage: $0 [-p profile] [-n new_hostname] [--hostname-only NEWNAME]
  -p profile        Override auto-detected profile (e.g. personal, work)
  -n new_hostname   Set macOS ComputerName/HostName/LocalHostName first
  --hostname-only NEWNAME   Only set the hostnames and exit (requires sudo)
USAGE
}

set_hostnames() {
  local newname="$1"
  # Validate hostname characters (Bonjour rules)
  if [[ ! "$newname" =~ ^[A-Za-z0-9-]+$ ]]; then
    echo "Error: hostname must contain only letters, numbers, and hyphens." >&2
    exit 2
  fi

  fancy_echo "Setting hostnames to '$newname'…"
  sudo scutil --set ComputerName "$newname"
  sudo scutil --set HostName "$newname"
  sudo scutil --set LocalHostName "$newname"
  sudo dscacheutil -flushcache
}

run_profile_tasks() {
  local profile="$1"
  case "$profile" in
    work)
      fancy_echo "Running work profile tasks…"
      # Placeholder for work-specific setup steps
      ;;
    personal)
      fancy_echo "Running personal profile tasks…"
      # Placeholder for personal-specific setup steps
      ;;
    *)
      # default / no-op
      ;;
  esac
}

install_homebrew() {
  if ! command_exists brew; then
    fancy_echo "Installing Homebrew..."
    /bin/bash -c "$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)"
    if [ -x /opt/homebrew/bin/brew ]; then
      eval "$(/opt/homebrew/bin/brew shellenv)"
    elif [ -x /usr/local/bin/brew ]; then
      eval "$(/usr/local/bin/brew shellenv)"
    fi
  else
    fancy_echo "Homebrew already installed."
  fi
}

install_mise() {
  if ! command_exists mise; then
    fancy_echo "Installing mise via Homebrew..."
    brew install mise
  else
    fancy_echo "mise already installed."
  fi
  eval "$(mise activate bash)" || true
}

install_1password_cli() {
  if ! command_exists op; then
    fancy_echo "Installing 1Password CLI via mise..."
    mise use -g 1password
  else
    fancy_echo "1Password CLI already installed."
  fi
  eval "$(mise activate bash)" || true
}

install_gh_cli() {
  if ! command_exists gh; then
    fancy_echo "Installing GitHub CLI via mise..."
    mise use -g gh
  else
    fancy_echo "GitHub CLI already installed."
  fi
  eval "$(mise activate bash)" || true
}

install_chezmoi() {
  if ! command_exists chezmoi; then
    fancy_echo "Installing chezmoi via mise..."
    mise use -g chezmoi
  else
    fancy_echo "chezmoi already installed."
  fi
  eval "$(mise activate bash)" || true
}

ensure_restic_sudoers() {
  local file=/etc/sudoers.d/restic-snapshot
  local tmp
  tmp=$(mktemp)
  cat >"$tmp" <<EOF_SUDO
# restic snapshot privileges for $USER
$USER ALL=(root) NOPASSWD: \
    /usr/bin/tmutil *, \
    /sbin/mount_apfs *, \
    /sbin/umount *, \
    /usr/sbin/diskutil unmount *
EOF_SUDO
  if ! sudo test -f "$file" || ! sudo cmp -s "$tmp" "$file"; then
    sudo install -m 0440 -o root -g wheel "$tmp" "$file"
    sudo visudo -cf "$file" || { echo "sudoers syntax error"; exit 1; }
    fancy_echo "Updated $file"
  fi
  rm -f "$tmp"
}

restic_backup_config_path() {
  local default_config_home="$HOME/.config"
  local xdg_config_home="${XDG_CONFIG_HOME:-$default_config_home}"
  if [[ -n "${RESTIC_BACKUP_CONFIG:-}" ]]; then
    printf "%s\n" "$RESTIC_BACKUP_CONFIG"
  else
    printf "%s/restic-backup/config.toml\n" "$xdg_config_home"
  fi
}

restic_config_python() {
  if [[ -n "${RESTIC_CONFIG_PYTHON_PATH:-}" ]]; then
    printf "%s\n" "$RESTIC_CONFIG_PYTHON_PATH"
    return 0
  fi

  if command_exists python3 && python3 - <<'PY' >/dev/null 2>&1
import tomllib  # noqa: F401
PY
  then
    RESTIC_CONFIG_PYTHON_PATH="$(command -v python3)"
    printf "%s\n" "$RESTIC_CONFIG_PYTHON_PATH"
    return 0
  fi

  if ! command_exists mise; then
    echo "Error: python3 with tomllib is required to parse restic config and mise is unavailable." >&2
    return 1
  fi

  fancy_echo "Installing Python runtime via mise for restic config parsing..."
  local python_version=""
  if ! python_version="$(mise latest python 3)"; then
    echo "Error: unable to determine latest Python 3 via mise." >&2
    return 1
  fi
  if [[ -z "$python_version" ]]; then
    echo "Error: mise returned empty Python version." >&2
    return 1
  fi

  if ! mise install "python@${python_version}"; then
    echo "Error: failed to install python@${python_version} via mise." >&2
    return 1
  fi
  if ! mise use -g "python@${python_version}"; then
    echo "Error: failed to activate python@${python_version} globally via mise." >&2
    return 1
  fi
  eval "$(mise activate bash)" || true

  if command_exists python3 && python3 - <<'PY' >/dev/null 2>&1
import tomllib  # noqa: F401
PY
  then
    RESTIC_CONFIG_PYTHON_PATH="$(command -v python3)"
    printf "%s\n" "$RESTIC_CONFIG_PYTHON_PATH"
    return 0
  fi

  echo "Error: python3 with tomllib remains unavailable after mise install." >&2
  return 1
}

print_restic_secret_requirements() {
  cat <<'EOF'
Restic keychain provisioning requirements:
  [defaults]
  target_host = "<configured host>"

  [repositories.<host>]
  uri = "rclone:..."
  password_service = "restic-repo-<host>"
  onepassword_ref = "op://... password/password"

Notes:
  - On hlru5i, mac_setup provisions all configured repository services.
  - On other hosts, mac_setup provisions the current host service (or defaults.target_host fallback).
  - Expected 1Password field is `password`.
  - A Python runtime with tomllib is required and will be installed via mise when missing.
EOF
}

restic_target_host_from_config() {
  local config_path="$1"
  if [[ ! -r "$config_path" ]]; then
    echo "Error: restic config not found: $config_path" >&2
    return 1
  fi

  local parser_python=""
  if ! parser_python="$(restic_config_python)"; then
    return 1
  fi

  if ! "$parser_python" - "$config_path" <<'PY'
import sys
import tomllib
from pathlib import Path

path = Path(sys.argv[1]).expanduser()
with path.open("rb") as handle:
    data = tomllib.load(handle)

repositories = data.get("repositories")
if not isinstance(repositories, dict) or not repositories:
    print("Error: expected non-empty [repositories] table in restic config", file=sys.stderr)
    raise SystemExit(1)

defaults = data.get("defaults")
if not isinstance(defaults, dict):
    print("Error: missing [defaults] table in restic config", file=sys.stderr)
    raise SystemExit(1)

target_host = defaults.get("target_host")
if not isinstance(target_host, str) or not target_host.strip():
    print("Error: defaults.target_host must be a non-empty string", file=sys.stderr)
    raise SystemExit(1)

target_host = target_host.strip()
if target_host not in repositories:
    print(
        f"Error: defaults.target_host '{target_host}' is not defined under [repositories]",
        file=sys.stderr,
    )
    raise SystemExit(1)

print(target_host)
PY
  then
    return 1
  fi
}

restic_repository_specs_from_config() {
  local config_path="$1"
  if [[ ! -r "$config_path" ]]; then
    echo "Error: restic config not found: $config_path" >&2
    return 1
  fi
  local parser_python=""
  if ! parser_python="$(restic_config_python)"; then
    return 1
  fi

  if ! "$parser_python" - "$config_path" <<'PY'
import sys
import tomllib
from pathlib import Path


def fail(message: str) -> "None":
    print(f"Error: {message}", file=sys.stderr)
    raise SystemExit(1)


path = Path(sys.argv[1]).expanduser()
with path.open("rb") as handle:
    data = tomllib.load(handle)

repositories = data.get("repositories")
if not isinstance(repositories, dict) or not repositories:
    fail("expected non-empty [repositories] table in restic config")

seen_services: dict[str, str] = {}

for host in sorted(repositories):
    value = repositories[host]
    if not isinstance(value, dict):
        fail(f"[repositories.{host}] must be a table")

    uri = value.get("uri")
    service = value.get("password_service")
    onepassword_ref = value.get("onepassword_ref")

    if not isinstance(uri, str) or not uri.strip():
        fail(f"[repositories.{host}].uri must be a non-empty string")
    if not isinstance(service, str) or not service.strip():
        fail(f"[repositories.{host}].password_service must be a non-empty string")
    if not isinstance(onepassword_ref, str) or not onepassword_ref.strip():
        fail(f"[repositories.{host}].onepassword_ref must be a non-empty string")

    service = service.strip()
    onepassword_ref = onepassword_ref.strip()
    if "|" in service or "|" in onepassword_ref:
        fail(f"[repositories.{host}] values may not include '|'")
    if service in seen_services:
        previous_host = seen_services[service]
        fail(
            f"duplicate password_service '{service}' in [repositories.{host}] "
            f"and [repositories.{previous_host}]"
        )
    seen_services[service] = host
    print(f"{host}|{service}|{onepassword_ref}")
PY
  then
    return 1
  fi
}

restic_repository_spec_for_host() {
  local wanted_host="$1"
  shift

  local spec=""
  local spec_host=""
  for spec in "$@"; do
    IFS='|' read -r spec_host _ <<<"$spec"
    if [[ "$spec_host" == "$wanted_host" ]]; then
      printf "%s\n" "$spec"
      return 0
    fi
  done
  return 1
}

ensure_keychain_item_from_1password() {
  local service="$1"
  local op_password_path="$2"
  local account="$3"
  local keychain="$4"

  if security find-generic-password -a "$account" -s "$service" "$keychain" >/dev/null 2>&1 \
    && [[ "${RESTIC_KEYCHAIN_FORCE_UPDATE:-0}" != "1" ]]; then
    fancy_echo "Restic keychain item already exists (%s)." "$service"
    return
  fi

  if [[ "${RESTIC_KEYCHAIN_FORCE_UPDATE:-0}" == "1" ]]; then
    fancy_echo "Updating restic keychain item (%s)..." "$service"
  else
    fancy_echo "Adding restic keychain item (%s)..." "$service"
  fi

  if ! command_exists op; then
    echo "Error: 1Password CLI (op) not found; cannot fetch restic secret for '$service'." >&2
    exit 1
  fi

  if [[ -z "$op_password_path" ]]; then
    echo "Error: 1Password path for restic service '$service' is empty." >&2
    print_restic_secret_requirements >&2
    exit 1
  fi

  local restic_pass=""
  if ! restic_pass=$(op read "$op_password_path"); then
    echo "Error: failed to read restic secret for '$service' from '$op_password_path'." >&2
    exit 1
  fi
  if [[ -z "$restic_pass" ]]; then
    echo "Error: 1Password secret for '$service' from '$op_password_path' is empty." >&2
    exit 1
  fi

  security add-generic-password -a "$account" -s "$service" -w "$restic_pass" -U \
    -T /usr/bin/security \
    "$keychain" >/dev/null
}

verify_restic_keychain_passwords() {
  local account="$1"
  local keychain="$2"
  shift 2
  local services=("$@")
  local service=""
  local missing=()

  for service in "${services[@]}"; do
    if ! security find-generic-password -a "$account" -s "$service" "$keychain" >/dev/null 2>&1; then
      missing+=("$service")
    fi
  done

  if [[ ${#missing[@]} -gt 0 ]]; then
    echo "Error: missing restic keychain item(s) after provisioning: ${missing[*]}" >&2
    exit 1
  fi

  fancy_echo "Verified restic keychain item(s): %s" "${services[*]}"
}

ensure_restic_keychain_passwords() {
  local account="$USER"
  local keychain="${RESTIC_KEYCHAIN_PATH:-$HOME/Library/Keychains/login.keychain-db}"
  local current_host
  current_host="$(scutil --get ComputerName 2>/dev/null || hostname)"
  current_host="${current_host%%.*}"

  local config_path
  config_path="$(restic_backup_config_path)"

  local target_host
  target_host="$(restic_target_host_from_config "$config_path")"

  local repository_specs=()
  while IFS= read -r spec; do
    [[ -n "$spec" ]] && repository_specs+=("$spec")
  done < <(restic_repository_specs_from_config "$config_path")

  if [[ ${#repository_specs[@]} -eq 0 ]]; then
    echo "Error: no restic repositories discovered from config: $config_path" >&2
    exit 1
  fi

  local selected_specs=()
  if [[ "$current_host" == "hlru5i" ]]; then
    selected_specs=("${repository_specs[@]}")
    fancy_echo "Provisioning restic keychain items for all configured hosts on %s." "$current_host"
  else
    local selected_host="$current_host"
    local selected_spec=""
    selected_spec="$(restic_repository_spec_for_host "$selected_host" "${repository_specs[@]}" || true)"

    if [[ -z "$selected_spec" ]]; then
      selected_host="$target_host"
      selected_spec="$(restic_repository_spec_for_host "$selected_host" "${repository_specs[@]}" || true)"
    fi

    if [[ -z "$selected_spec" ]]; then
      echo "Error: no repository mapping found for current host '$current_host' or target host '$target_host'." >&2
      print_restic_secret_requirements >&2
      exit 1
    fi

    selected_specs=("$selected_spec")
    fancy_echo "Provisioning restic keychain item for host %s." "$selected_host"
  fi

  local services_to_verify=()
  local spec=""
  local spec_host=""
  local service=""
  local op_password_path=""
  for spec in "${selected_specs[@]}"; do
    IFS='|' read -r spec_host service op_password_path <<<"$spec"
    if [[ -z "$service" || -z "$op_password_path" ]]; then
      echo "Error: invalid repository spec for host '$spec_host': $spec" >&2
      exit 1
    fi
    services_to_verify+=("$service")
    ensure_keychain_item_from_1password "$service" "$op_password_path" "$account" "$keychain"
  done

  verify_restic_keychain_passwords "$account" "$keychain" "${services_to_verify[@]}"
}

update_homebrew() {
  brew update --auto-update

  # ruby dependencies
  brew install openssl@3 readline libyaml gmp autoconf

  brew upgrade
  brew bundle install
  brew cleanup --prune=all
}

update_mise() {
  mise cache clear
  mise install
  mise upgrade --yes
  mise prune --yes
}

install_awscli() {
  mise install awscli "ref:$(mise latest awscli 2)"
  mise use -g "awscli@$(mise latest awscli 2)"
}

install_pragmasevka_font() {
  local font_dir="$HOME/Library/Fonts"

  # If the regular style is already present, assume the font is installed.
  if find "$font_dir" -maxdepth 1 -iname "pragmasevka-nf-regular.ttf" | grep -q .; then
    fancy_echo "Pragmasevka font already installed – skipping download."
    return
  fi

  local url="https://github.com/shytikov/pragmasevka/releases/download/v1.7.0/Pragmasevka_NF.zip"
  local expected_sha="eeab758eff562d1caed761244488e56545be25e81a6b40cd84b31b032a37615c"
  local tmp_dir
  tmp_dir=$(mktemp -d)
  local zip_file="$tmp_dir/Pragmasevka_NF.zip"

  fancy_echo "Downloading Pragmasevka font..."
  curl -LfsS -o "$zip_file" "$url"

  fancy_echo "Verifying SHA256 checksum..."
  local actual_sha
  actual_sha=$(shasum -a 256 "$zip_file" | awk '{print $1}')
  if [ "$actual_sha" != "$expected_sha" ]; then
    echo "SHA256 checksum mismatch for Pragmasevka font" >&2
    echo "Expected: $expected_sha" >&2
    echo "Actual:   $actual_sha" >&2
    exit 1
  fi

  fancy_echo "Checksum verified. Installing font..."

  unzip -q "$zip_file" -d "$tmp_dir"

  mkdir -p "$font_dir"
  find "$tmp_dir" -type f \( -name "*.ttf" -o -name "*.otf" \) -exec cp -f {} "$font_dir/" \;

  fancy_echo "Pragmasevka font installed."
}

update_system() {
  sudo softwareupdate --download --all --agree-to-license || true
}

init_chezmoi() {
  install_chezmoi
  fancy_echo "Initializing chezmoi from $SCRIPT_DIR"
  chezmoi init --source "$SCRIPT_DIR" --apply
}

mac_system_setup() {
  fancy_echo "Setting up macOS system..."

  sudo sysctl -w kern.maxfiles=524288
  sudo sysctl -w kern.maxfilesperproc=262144

  # set launchd per-process soft/hard (use numbers, not "unlimited")
  sudo launchctl limit maxfiles 262144 524288
  ensure_limit_maxfiles_launchdaemon 262144 524288

  # 3 is default hibernate mode; copy RAM to hibernation file but keeps RAM powered on.
  # 25 is the most aggressive mode; copy RAM to hibernation file and power off RAM.
  sudo pmset -a hibernatemode 3

  # After 1800 seconds (30 minutes), the system will go into standby mode, which is
  # actually hibernation! (This does not work at least on Mac M1)
  # sudo pmset -a standbydelay 1800

  # Disable Power Nap, which keeps networking alive.
  sudo pmset -a powernap 0

  # Show hidden files in Finder
  defaults write com.apple.Finder AppleShowAllFiles -bool true

  # Show all file extensions in Finder
  defaults write NSGlobalDomain AppleShowAllExtensions -bool true

  # Show the path bath and status bar in Finder
  defaults write com.apple.finder ShowPathbar -bool true
  defaults write com.apple.finder ShowStatusBar -bool true

  # Use list view and search the current folder by default
  defaults write com.apple.Finder FXPreferredViewStyle -string "Nlsv"
  defaults write com.apple.Finder FXDefaultSearchScope -string "SCcf"

  # Unhide the Library folder
  chflags nohidden ~/Library

  # Show the full POSIX path in Finder window titles
  defaults write com.apple.finder _FXShowPosixPathInTitle -bool true

  # Show the ~/Downloads folder in the sidebar
  defaults write com.apple.finder ShowRecentTags -bool false
  defaults write com.apple.finder ShowSidebar -bool true

  # Change screenshot save location
  mkdir -p ~/Pictures/Screenshots
  defaults write com.apple.screencapture location ~/Pictures/Screenshots
  killall SystemUIServer || true

  # Always show scroll bars
  defaults write NSGlobalDomain AppleShowScrollBars -string "Always"

  # Enable tap‑to‑click and two‑finger right‑click
  defaults write com.apple.driver.AppleBluetoothMultitouch.trackpad Clicking -bool true
  defaults write com.apple.AppleMultitouchTrackpad TrackpadRightClick -bool true

  # Increase keyboard repeat speed
  defaults write -g InitialKeyRepeat -int 10
  defaults write -g KeyRepeat -int 1

  # Turn off automatic spelling correction and capitalisation
  defaults write NSGlobalDomain NSAutomaticSpellingCorrectionEnabled -bool false
  defaults write NSGlobalDomain NSAutomaticCapitalizationEnabled -bool false

  # Restart Finder
  killall Finder || true
}

update_cursor_agent() {
  fancy_echo "Updating Cursor agent..."
  if command -v cursor-agent >/dev/null 2>&1; then
    cursor-agent update
  else
    fancy_echo "Cursor agent not installed."
  fi
}

main() {
  # Parse CLI flags early
  local PROFILE=""
  local NEW_HOSTNAME=""
  while getopts "p:n:h" opt; do
    case $opt in
      p) PROFILE=$OPTARG ;;
      n) NEW_HOSTNAME=$OPTARG ;;
      h)
        usage
        return 0
        ;;
      *)
        usage
        return 1
        ;;
    esac
  done
  shift $((OPTIND - 1))

  # Optionally set a new hostname
  if [[ -n "$NEW_HOSTNAME" ]]; then
    set_hostnames "$NEW_HOSTNAME"
  fi

  # Auto-detect profile from current hostname if not provided
  if [[ -z "$PROFILE" ]]; then
    local CURRENT_HOST
    CURRENT_HOST=$(scutil --get ComputerName 2>/dev/null || hostname)
    case "$CURRENT_HOST" in
      hlru5i|im9ibk) PROFILE="personal" ;;
      yov3bc|okzf68) PROFILE="work"     ;;
      *)             PROFILE="default"  ;;
    esac
  fi

  run_profile_tasks "$PROFILE"

  keep_sudo_alive

  install_homebrew
  install_mise
  install_1password_cli
  install_gh_cli
  init_chezmoi
  ensure_restic_keychain_passwords
  ensure_restic_sudoers

  mac_system_setup
  install_pragmasevka_font
  update_homebrew
  install_awscli
  update_mise
  update_system
  update_cursor_agent
  fancy_echo "Mac setup/update complete for profile '$PROFILE'."
}

# Allow unit-style function testing without running main.
if [[ "${MAC_SETUP_SKIP_MAIN:-0}" == "1" ]]; then
  if [[ "${BASH_SOURCE[0]}" != "$0" ]]; then
    return 0
  fi
  exit 0
fi

# If invoked directly with --hostname-only NEWNAME, handle it before main()
if [[ ${1:-} == "--hostname-only" ]]; then
  if [[ $# -ne 2 ]]; then
    echo "Usage: $0 --hostname-only NEWNAME" >&2
    exit 1
  fi
  if [[ ${EUID:-$(id -u)} -ne 0 ]]; then
    echo "Error: --hostname-only must be run with sudo." >&2
    exit 1
  fi
  keep_sudo_alive
  set_hostnames "$2"
  exit 0
fi

main "$@"
